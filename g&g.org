* gdb

** 设置命令行参数

  set args [参数1] [参数2] ....
  show args 显示设置好的参数

** 断点

*** 设置断点

   b [行号] : 在指定行设置断点.
   b [文件名:行号] : 在指定文件的指定行设置断点.
   b [函数名] : 在指定函数处设置断点.
   b [位置] if 条件 : 设置条件断点.

*** 显示断点信息

   info b (i b)
   
*** 禁用/启用断点
    
    disable/enable [断点号]

*** 删除断点

   d : 删除所有断点.
   d [断点号] : 删除指定断点.
   d [n-m] : 删除断点n至m.
   

** 显示变量

  p [变量] : 显示变量值.
  p *array@len : 显示动态分配的数组array的前len个元素.

*** 自动显示

  display [/f] [表达式] : 每一步中都自动显示表达式的值, 以格式f显示.
  undisplay [编号] : 删除指定的自显量.
  disable/enable display [编号] : 禁用/启用指定的自显量.
  info display : 查看所有自显量的信息.

** 调试

  n(ext) [数字] : 单步运行,不进入函数. 数字表示一次进行几步.
  s(tep) [数字] : 单步运行,进入函数. 数字表示一次进行几步.
  c(ontinue)   : 继续执行程序,直到下一个断点或程序结束. 
  finish : 退出函数.
  bt(backtrace) : 查看函数调用栈.
  k(ill) : 终止当前程序的运行,但不退出GDB.
  r : 重新执行调试过程.可用于重新调试重新编译后的可执行程序,不用退出gdb.

** 查看调用栈信息

   bt: 显示调用栈信息.
   frame [栈编号]
   
** 反汇编

   disas [函数名] : 反汇编指定函数.

* gcc

   只处理'.c'文件, 不处理'.h'文件.

** 预处理(-E)

   对源文件进行预处理,生成预处理过的代码(.i)
   gcc -E file.c -o file.i 
    
** 编译(-S)

   文本 -> 文本: 对预处理过的代码进行编译(语法解析和汇编代码生成),生成
   汇编语言代码(.s)
   
   gcc -S file.i(c) -o file.s
   -masm=intel : 产生intel格式的汇编语言.

** 汇编(-c)
   
   文本 -> 二进制机器码: 对汇编语言代码进行汇编,生成二进制的目标文件
   (.o)机器代码的生成与处理器有密切的联系,相对于编译过程的语法解析,汇
   编的过程相对简单,这是因为对于一款特定的处理器，其汇编语言和二进制的
   机器代码是一一对应的gcc -c file.s(c) -o file.o
   
** 链接
   
   对多个二进制目标文件进行链接,生成可执行文件.
   gcc file_1.o file_2.o file_3.o .... -o file

** 库
   
   当静态库与动态库同名时,gcc优先选择动态库,系统会自动搜寻在/lib/(内核
   级),/usr/lib/(系统级),和/usr/local/lib/(用户级)目录下的库.

   -L[目录] : 添加(动态/静态)库文件目录.
   -l[库名] : 添加库文件.

   nm libxxx.so(a) : 查看库中所定义的符号(T表示该库所定义的符号,U表示
   该库所引用的符号,w表示弱符号). 可用: 'nm libxxx.so(a) | grep U/T/w'
   来查看
   
   命名规则: libxxx.so(a).主版本号.次版本号

   注: 如果文件a依赖于文件b, 那么编译的时候必须把a放前面b放后面.

*** 动态库

    命名: lib[库名].so
    创建: 由多个.o文件链接而成.
    gcc -shared file1.o file2.o ...  -o lib[库名].so
    注:其中每个file.o编译时必须加入-fPIC.

    加载: 
    2.环境变量LD_LIBARY_PATH中指定的路径.
    3.在/etc/ld.so.conf.d/目录下新建一个文件(pz.conf),并将动态库库所在
    的目录添加到该文件中,然后运行ldconfig命令(需要root权限).
          
*** 静态库

    命名: lib[名称].a
    创建: 由多个.o文件打包而成.
    ar -rc lib[库名].a file1.o file2.o ... 

** 常用选项

   -I[目录] : 添加头文件搜索目录. ('.c'文件中,include的'.h'文件可以不用添加路径)
   -fPIC(Position Independent Code): 生成位置无关的代码,编译动态库的.o文件时必须加上该参数.
   -shared: 多个.o文件链接成.so文件时必须加上该参数.
   -m32/-m64 : 编译成32/64位汇编代码.
   -save-temps : 保存所有中间文件(.i, .s, .o).
   -Wextra : 生成额外的警告信息.
   @file : gcc的编译选项将从file中读取, 其中每个编译选项由空格分隔.
   -static : 不使用动态库, 把所有库文件打包在一起生成可执行文件.

** 地址空间随机化(ALSR)
   
   通过变量 '/proc/sys/kernel/randomize_va_space' 来修改: 2表示打开,0表示关闭.
   修改方法: echo 0/1/2 > /proc/sys/kernel/randomize_va_space


* git

** 配置

*** 配置文件: 

    每一个项目都有一个.git目录,用于保存该项目的所有数据.

    /etc/gitconfig : 系统中对所有用户都普遍适用的配置. (--system)
    ~/.gitconfig : 用户目录下的配置文件只适用于该用户. (--global)
    .git/config : 当前项目的 git 目录中的配置文件, 仅仅针对当前项目有效.
    注：每一个级别的配置都会覆盖上层的相同配置. 所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量.

*** 配置选项   

    git config --global user.name ["用户名"] : 设置用户名.
    git config --global user.email [电子邮箱] : 设置邮箱.
    git config --global core.editor [文本编辑器]: 设置默认文本编辑器.
    git config --global merge.tool [ediff] : 将ediff设置为差异分析工具.
    
    注:如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息

    git config --list : 查看已有的配置信息.
    git config [变量] : 查看某个[变量]的值. 如: 'git config user.name'.
    
** 初始化新仓库
   
   要对现有的某个项目开始用git管理,只需到此项目所在的目录初始化一个新
   的git仓库.

   git init : 将当前工作目录初始化为新的仓库(.git),但还没有跟踪任何文件.
   
   .gitignore : 存放所有将被git忽略的文件格式.
   
** 查看文件状态

   git status : 查看当前目录下各文件的状态.
   git diff : 查看工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化.
       --cached(staged) : 查看暂存区文件和最近一次提交的快照之间的差异.

** 添加/删除暂存区文件

   git add [文件或目录] : 将指定文件或目录加入暂存区,同时将未跟踪的文件(目录)标记为已跟踪.
   git reset HEAD [文件] : 将指定文件移出暂存区(恢复为"已修改未暂存"状态).

** 提交更新
   
***   git commit : 将暂存区的文件提交,提交后暂存区将为空.(将启动文本编辑器用于编写本次提交的说明)

   -m '提交说明' : 直接在命令行中编写提交说明.
   -a : 跳过暂存区,把所有已经跟踪过的文件暂存起来一并提交.(跳过git add步骤)
   --amend : 提交当前暂存区的内容,覆盖上一次提交(用于撤销上一次提交).
   
***   git log : 查看提交历史.

    -p 按补丁格式显示每个更新之间的差异.
    -(n) 仅显示最近的 n 条提交.
    --since, --after 仅显示指定时间之后的提交.
    --until, --before 仅显示指定时间之前的提交.
    --author 仅显示指定作者相关的提交.
    --committer 仅显示指定提交者相关的提交.
    --stat 显示每次更新的文件修改统计信息.
    --shortstat 只显示 --stat 中最后的行数修改添加移除统计.
    --name-only 仅在提交信息后显示已修改的文件清单.
    --name-status 显示新增、修改、删除的文件清单.
    --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符.
    --relative-date 使用较短的相对时间显示(比如2 weeks ago)
    --graph 显示 ASCII 图形表示的分支合并历史.
    --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。
    --pretty=format:"%h - %an, %ar : %s"
	 %H 提交对象（commit）的完整哈希字串
	 %h 提交对象的简短哈希字串
	 %T 树对象（tree）的完整哈希字串
	 %t 树对象的简短哈希字串
	 %P 父对象（parent）的完整哈希字串
	 %p 父对象的简短哈希字串
	 %an 作者（author）的名字
	 %ae 作者的电子邮件地址
	 %ad 作者修订日期（可以用 -date= 选项定制格式）
	 %ar 作者修订日期，按多久以前的方式显示
	 %cn 提交者(committer)的名字
	 %ce 提交者的电子邮件地址
	 %cd 提交日期
	 %cr 提交日期，按多久以前的方式显示
	 %s 提交说明

** 移除文件   

   git rm [文件] : 将指定文件从git仓库中移除,同时删除该文件本身.(只能移除未暂存的.)
   --cache : 仅从git仓库中删除(不再跟踪),仍在工作目录中保留原文件.(常用)
   -f : 强制删除已暂存的文件.
   -r : 用于递归地删除目录.

** 移动(重命名)文件

   git mv [file_from] [file_to] : 将文件[file_from]移动至[file_to]

** 移除已暂存文件
** 取消对文件的修改

   git checkout [文件] : 取消对当前文件的修改,恢复到以前版本(把之前版本的文件复制过来重写了此文件).(较危险不可逆)

** 远程分支
   
   注:一个本地仓库(项目),可以有多个远程仓库(对应不同开发者).

   git remote : 查看本地仓库所对应的每个远程库的简短名字.
       -v : 同时显示地址.
   git remote show [远程仓库名] : 查看本地git仓库拥有的远程仓库信息.

   git clone [仓库的url] [名称]: 将指定远程仓库克隆到当前目录下,并为其
   命名.(若未指定名称,则用远程仓库的原名称.)

   git remote add [名称] [远程仓库URL] : 为当前本地仓库添加远程仓库,并
   设置其名称(一个本地仓库可以有多个远程仓库), 以后便可用名称引用该远
   程仓库. 首先在github上新建一个repository, 然后添加远程仓库URL:
   git@github.com:pz239/yourrepository.git

   git remote rm [远程仓库名] : 为当前仓库删除指定远程仓库.(并不会删除
   远程服务器上的仓库,只是删除其在本地的映像)

   git remote rename [原名称] [新名称] : 修改远程仓库在本地的简称.

   远程分支是特定远程仓库中相应分支在本地的记录,它们是一些无法移动的本
   地分支,用 '(远程仓库名)/(分支名)' 来表示.

   git fetch [远程仓库名] : 将指定远程仓库的数据(各个分支),同步到本地
   仓库中相应的远程分支(并不进行分支合并),若远程仓库中出现新分支,则在
   本地仓库中建立对应的远程分支.

*** 推送本地分支到远程仓库

   git push [远程仓库名] [分支名] : 推送指定分支到指定远程仓库,名称不
   变.(可用于给远程仓库添加新的分支).

   git push [远程仓库名] [分支1名]:[分支2名] : 推送分支1到指定远程仓库,并
   命名为分支2名.

*** 跟踪远程分支

    从远程分支 checkout 出来的本地分支,称为跟踪分支.跟踪分支是一种和某
    个远程分支有直接联系的本地分支.在跟踪分支里输入 'git push', Git 会
    自行推断应该向哪个服务器的哪个分支推送数据,同样,在这些分支里运行
    'git pull' 会获取所有远程索引,并把它们的数据都合并到本地分支中来.
    
    git checkout -b [本地分支名] [远程仓库名]/[分支名] : 在本地创建一个指定分支来跟踪远程分支.  
    git checkout --track [远程仓库名]/[分支名] : 在本地创建一个同名分支来跟踪远程分支.

*** 删除远程仓库中的分支

    git push [远程仓库名]:[分支名] : 删除远程仓库里的指定分支.

** 本地分支

   名为HEAD的指针指向当前分支.
   
*** 创建新分支

    git branch [新分支名] : 在当前提交对象上创建新分支,但并不切换到该分支.(HEAD指针仍指向原分支)

*** 切换分支

    注: 切换分支前,最好先提交当前分支,保证一个清洁的工作区域.
    git checkout [分支] : 切换到指定分支.(HEAD指针移动到指定分支,同时将工作环境切换到指定分支)
       -b : 新建并切换到新分支.
    
*** 重命名本地分支
    
    git branch -m [原分支名] [新分支名]

*** 删除分支
    
    git branch -d [分支] : 删除指定分支.(用于删掉已经被合并的分支, 无法删除未被合并的分支)
    git branch -D [分支] : 强制删除指定分支,无论其合并与否.

*** 合并分支

    注:如果顺着一个分支走下去可以到达另一个分支的话,那么Git在合并两者
    时,只会简单地分支指针右移,因为这种单线的历史分支不存在任何需要解决
    的分歧,所以这种合并过程可以称为快进(Fast forward).如果在不同的分支
    中都修改了同一个文件的同一部分,Git 就无法干净地把两者合到一起,需要
    由开发者来裁决. 注: 存在冲突的文件经人工处理后, 需要用"git add"命
    令添加到暂存区, 表示已冲突已解决.
    
    git merge [分支名] : 将指定分支合并到当前分支.

*** 人工解决冲突
    
    1. 在执行分支合并后,使用'git status'来查看哪些文件存在冲突.
    2. 直接打开文件手动或调用工具解决冲突.
    3. 使用'git add [冲突文件]' 将处理完冲突后的文件重新加入暂存区.

*** 管理分支

    git branch : 无参数则列出当前所有分支.('*'表示当前所在分支)
    -v : 查看各个分支最后一次提交的提交说明.
    --merge : 列出已经与当前分支合并的分支(可以用"git branch -d"删除掉).
    --no-merged : 列出尚未与当前分支合并的分支.
    
** 衍合

   git rebase [基底分支名] : 将当前分支衍合到基底分支.  注:它的原理是
   回到两个分支最近的共同祖先,根据当前分支后续的历次提交对象,生成一系
   列文件补丁,然后以基底分支最后一个提交对象为新的出发点,逐个应用之前
   准备好的补丁文件,最后会生成一个新的合并提交对象.
   
   git rebase [基底分支名] [特性分支名] : 将特性分支衍合到基底分支.
** 储藏(stash)

   git stash : 将当前工作目录中的中间状态,保存在堆栈中,随时可以重新恢复.
   git stash list : 查看现有的储藏.
